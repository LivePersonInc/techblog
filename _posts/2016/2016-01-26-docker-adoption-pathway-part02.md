---
layout: post
title:  "Docker adoption pathway - Part 2"
date:   2016-01-26 22:18:00
categories: software-development,architecture,design
comments: true
author: Tomer Ben-David
published: false
---
# Docker adoption pathway - Part 2

**App and deployment types** You must be having many flavours of servers.  You must be having http style servers, but do you have also storm topologies? hadoop jobs? spark? spark streaming? `vert.x`? databases? which flavours? That means you should cosinder which server types are your candidates for `docker` adoption.  Usually you wish to start with plain servers, `web/app` servers as opposed to converting any kind of `databases` or servers which are not in frequent development and deployment.  Also in most cases you would need to scale up and down your `web/app` servers, so again this makes them a good candidate, In addition those server's are almost completely in your control, so again it makes sense to start with these servers.  Among these you would first want to `POC` a few or a single non critical service, it's best that your first `POC` contains a server which if it's down no harm done.  do a full `docker` adotpion on it and test it.  Once you feel comfort and you have formed procedures and templates for `docker` adoption you may continue gradually to servers with higher criticallity and with stricter `SLA`.  Do you already use `YARN`, `Mesos`? What about spontaneous command run like `tcpdump` do you also consider them as `apps`? (hint: yes).  This means you need to take into consideration a heterogenous production system and see how docker would fit it.  Also as you consider `docker` you probably already consider using `kubernetes` (hint: yes), This has to philarmon all together.

**Tagging Convention** You might have already been tagging your app releases.  By tags we don't mean plain software versions but also meaningful names to your builds.  Docker taken this step up to convention it already holds the notion of tags.  So now you can be officially a software release tagger, and if you wondered in the past whether that was a good enough practice here is an affirmation to that.  But, you ha
 the version control revision where this image was created from, tag can be extremely useful for that, so tag with the info you not to much but not too less, I would not recommend not including for example teh version control revision the image was created from, you really want a super easy way to get to the source code of that build.

**Fast and Slow lane**  Your teams are already used to doing their tasks within the scopes of their roles, that is, development - providing tested artifacts to production while production team are in charge for their proper installation on production environments.  However, things are not always smooth, once you have a break fix, you have to consider how to perform a fix which should be both tested and delivered as fast as possible to production.  Now that your app is packaged with the `OS` itself, including its configuration, which is already bundled in the image, how would you still be able to perform a quick fix when needed?  When dealing with artifacts and their deployment on production you should always have two lanes.  Fast and Slow.  By all means the slow lane is used always.  Always except for the time you have no other choice and you need to make a fix on production immediately.  You should aspire never getting to that place, but you have to know you have such an option.  Let's emphasize this again, as much as you should avoid this option you must have this option available, even theoretically so that if time comes it's available for you.  With `containerized deployments` the fast lane should be checkout the image in production, perform the fix, commit and apply it with a proper `tag` marking this was a break fix.  It is quick enough to enable you to discard the option of login into a container and doing the updates, we favour that, at least here you were working on a versioned controlled image, you can do edit the container directly, but its's much less recommended as we want to work on a clean image and commit it, while you do this in parallel you provide the change in the slow lane.  The slow lane includes updating the source code in development env, creating a new image which goes through the cycle of all `CI`, tests and providing this image back to production which should then install it as a proper image.

