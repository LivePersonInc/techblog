---
layout: post
title:  "Docker adoption pathway - Part 2"
date:   2016-01-26 22:18:00
categories: software-development,architecture,design
comments: true
author: Tomer Ben-David
published: false
---
# Docker adoption pathway - Part 2

**Fast and Slow lane**  Your teams are already used to doing their tasks within the scopes of their roles, that is, development - providing tested artifacts to production while production team are in charge for their proper installation on production environments.  However, things are not always smooth, once you have a break fix, you have to consider how to perform a fix which should be both tested and delivered as fast as possible to production.  Now that your app is packaged with the `OS` itself, including its configuration, which is already bundled in the image, how would you still be able to perform a quick fix when needed?  When dealing with artifacts and their deployment on production you should always have two lanes.  Fast and Slow.  By all means the slow lane is used always.  Always except for the time you have no other choice and you need to make a fix on production immediately.  You should aspire never getting to that place, but you have to know you have such an option.  Let's emphasize this again, as much as you should avoid this option you must have this option available, even theoretically so that if time comes it's available for you.  With `containerized deployments` the fast lane should be checkout the image in production, perform the fix, commit and apply it with a proper `tag` marking this was a break fix.  It is quick enough to enable you to discard the option of login into a container and doing the updates, we favour that, at least here you were working on a versioned controlled image, you can do edit the container directly, but its's much less recommended as we want to work on a clean image and commit it, while you do this in parallel you provide the change in the slow lane.  The slow lane includes updating the source code in development env, creating a new image which goes through the cycle of all `CI`, tests and providing this image back to production which should then install it as a proper image.

**App and deployment types** You must be having many flavours of servers.  You must be having http style servers, but do you have also storm topologies? hadoop jobs? spark? spark streaming? `vert.x`? databases? which flavours? Do you already use `YARN`, `Mesos`? What about spontaneous command run like `tcpdump` do you also consider them as `apps`? (hint: yes).  This means you need to take into consideration a heterogenous production system and see how docker would fit it.  Also as you consider `docker` you probably already consider using `kubernetes` (hint: yes), This has to philarmon all together.

**Tagging Convention** You might have already been tagging your app releases.  By tags we don't mean plain software versions but also meaningful names to your builds.  Docker taken this step up to convention it already holds the notion of tags.  So now you can be officially a software release tagger, and if you wondered in the past whether that was a good enough practice here is an affirmation to that.  But, you ha
 the version control revision where this image was created from, tag can be extremely useful for that, so tag with the info you not to much but not too less, I would not recommend not including for example teh version control revision the image was created from, you really want a super easy way to get to the source code of that build.